---
title: 设计模式那点事儿——依赖注入的思考
tags: [develop,设计模式]
date: 2016-08-04 15:42:47
---
# 核心思想
**容器的思想**：将继承于同一抽象类（实现同一接口）的对象分别置于容器中，使用时，直接拿容器的某个属性进行操作，而不用关心容器中的这个属性在初始化的时候赋予的是哪个对象。

**依赖注入思想**：将这个可变的容器，以构造函数参数的形式注入到不变的对象中，从而在对象里调用容器中的已经约定好的方法，而不必关心这个传入的容器实例到底是哪个对象实例化的结果。

# 使用场景
1. 多个对象具有共同的特征及操作，使用时因业务逻辑不同而需要进行切换的。
1. 固定对象内需要引用相同类型的不同对象，而操作他们共同的方法，需要进行依赖注入。

# 实例代码
## 实例情景说明
支付宝和微信支付是两个具体的支付方式，共同继承于抽象的支付类。使用时可以进行任意的切换。
用户类中具有用户支付的行为，行为本身可以使用两种支付方式的任意一种，在构造时决定。

## 容器类
```php
/**容器类
 * Created by DannyWang
 * wangjue@mia.com
 * 2016/8/4
 */
class DI {
    private $obj_list_arr = array();// 容器存放数组
    protected static $instince = null;

    public static function getInstince() {// 单例模式
        if (self::$instince == null) {
            self::$instince = new DI();
        }
        return self::$instince;
    }

    function __get($name) {// 魔术方法，用于匿名赋值和调用
        return $this->obj_list_arr[$name];
    }

    function __set($name, $value) {
        $this->obj_list_arr[$name] = $value;
    }
}
```

## 支付抽象类
```php
abstract class PayMethod {
    abstract function pay($amount);
}
```

## 支付具体类A
```php
class AliPay extends PayMethod {
    public function pay($amount) {
       return ('alipay paid:' . $amount);
    }
}
```

## 支付具体类B
```php
class WechatPay extends PayMethod {
    public function pay($amount) {
        return ('wechatpay paid:' . $amount);
    }
}
```

## 用户类
```php
class User {
    private $_di;

    public function __construct($di) {// 构造函数接收传入的容器对象
        $this->_di = $di;
    }

    public function userPay($user_name, $amount) {
        echo $user_name . '-' . $this->_di->uPay->pay($amount);// 根据约定，调用容器对象内的方法，在更换容器内容后也不必修改代码！
    }
}
```

## 调用客户端
```php
// 容器
$di = DI::getInstince();
$di->onePay = new AliPay();// 填充容器
echo $di->onePay->pay(100);
echo '<br>';

$di->onePay = new WechatPay();// 填充容器 （更换了对象，但是都继承自同一个抽象类）
echo $di->onePay->pay(200);// 可以调用相同的方法
echo '<br>=========================<br>';

// 依赖注入实例
$di = DI::getInstince();
$di->uPay = new AliPay(); // 可变的容器内容
$user = new User($di); // 将可变的内容传入构造函数中，作为一个对象属性
$user->userPay('danny', 50);
echo '<br>';

$di->uPay = new WechatPay(); // 可变的容器内容(更换内容)
$user2 = new User($di); // 将可变的内容传入构造函数中，作为一个对象属性
$user2->userPay('danny', 60);//调用相同方法，输出不同的值
```

## 返回结果
```
alipay paid:100
wechatpay paid:200
=========================
danny-alipay paid:50
danny-wechatpay paid:60
```

# 进一步思考
依赖注入是提前“准备好”要依赖的类，但是这个准备的过程是否需要进行真正的实例化呢？
答案是：*可由我们自己控制*。

上面的例子是在准备的过程中便进行了实例化，如果需要在真正对象**使用的时候**才进行实例化，就需要用**匿名函数（或回调函数）**来实现了，看代码：

User类的改进：
```php
class User {
    private $_di;

    public function __construct($di) {
        $this->_di = $di;
    }

    public function userPay($user_name, $amount) {
        $obj=$this->_di->uPay;
        echo $user_name . '-' . $obj()->pay($amount); // 实例化并执行对象方法
    }
}
```

调用：
```php
$di = DI::getInstince();

$di->uPay = function () { //注入容器的是一个匿名函数（回调函数），只有在真正执行的时候才会实例化！
    return new AliPay(); //返回一个对象
};

var_dump('begin use object');
$user = new User($di); // 将可变的内容传入构造函数中，作为一个对象属性
$user->userPay('danny', 50);
```

结果：
```
E:\DannyCode\study\DI\client.php:42:string 'begin use object' (length=16)
E:\DannyCode\study\DI\AliPay.php:14:string 'call alipay construct' (length=21)
danny-alipay paid:50
```

# 一句话总结
**依赖注入**是指将当前类所依赖的其他类以参数形式（构造函数中）“注入”到当前类中的思想。

**控制反转**（IoC）是指提供一个“容器”将所依赖的类放入其中（可直接放入，可以回调方式放入），然后将这个容器注入到类中（或容器提供一个make对象的方法）的思想。

# 参考链接
[核心思想：DI依赖注入-让资源更可控](http://www.phalapi.net/wikis/%5B2.11%5D-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%EF%BC%9ADI%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-%E8%AE%A9%E8%B5%84%E6%BA%90%E6%9B%B4%E5%8F%AF%E6%8E%A7.html)

[laravel 学习笔记 —— 神奇的服务容器](https://www.insp.top/article/learn-laravel-container)